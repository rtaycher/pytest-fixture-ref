{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pytest fixture ref Documentation : https://rtaycher.github.io/pytest-fixture-ref Source Code : https://github.com/rtaycher/pytest-fixture-ref PyPI : https://pypi.org/project/pytest-fixture-ref/ Let developers reference pytest fixtures without name matching magic. Pass fixtures via default value or decorator args instead of magic strings. Let me admit this is a bit of a hack. It might be important to note that this still uses pytests usual magic string matching under the covers by grabbing the function name and re-writing the function. That means you do have to make sure pytest imports it by installing it/specifying it in pytest_plugins/etc as well as importing it for reference. It also means this technically works with fake/dummy functions with the same name (in case you can't easily import some fixtures) example: from pytest_fixture_ref import using_fixtures_from_defaults, using_fixtures_from_kwargs @using_fixtures_from_defaults def test_bar1(_=fix_w_yield1, __=fix_w_yield2, tmp=tmp_path): assert tmp.exists() @using_fixtures_from_kwargs(_=fix_w_yield1, __=fix_w_yield2, tmp=tmp_path) def test_bar2(_, __, tmp): assert tmp.exists() You can also use it to reference fixtures from other fixtures @pytest.fixture def first_entry(): return \"a\" @pytest.fixture @using_fixtures_from_defaults def order(fe=first_entry): return [fe] Installation pip install pytest-fixture-ref Development Clone this repository Requirements: Poetry Python 3.7+ Create a virtual environment and install the dependencies poetry install Activate the virtual environment poetry shell Testing pytest Documentation The documentation is automatically generated from the content of the docs directory and from the docstrings of the public signatures of the source code. The documentation is updated and published as a Github project page automatically as part each release. Releasing Trigger the Draft release workflow (press Run workflow ). This will update the changelog & version and create a GitHub release which is in Draft state. Find the draft release from the GitHub releases and publish it. When a release is published, it'll trigger release workflow which creates PyPI release and deploys updated documentation. Pre-commit Pre-commit hooks run all the auto-formatters (e.g. black , isort ), linters (e.g. mypy , flake8 ), and other quality checks to make sure the changeset is in good shape before a commit/push happens. You can install the hooks with (runs for each commit): pre-commit install Or if you want them to run only for each push: pre-commit install -t pre-push Or if you want e.g. want to run all checks manually for all files: pre-commit run --all-files This project was generated using the wolt-python-package-cookiecutter template.","title":"Introduction"},{"location":"#pytest-fixture-ref","text":"Documentation : https://rtaycher.github.io/pytest-fixture-ref Source Code : https://github.com/rtaycher/pytest-fixture-ref PyPI : https://pypi.org/project/pytest-fixture-ref/","title":"pytest fixture ref"},{"location":"#let-developers-reference-pytest-fixtures-without-name-matching-magic","text":"Pass fixtures via default value or decorator args instead of magic strings. Let me admit this is a bit of a hack. It might be important to note that this still uses pytests usual magic string matching under the covers by grabbing the function name and re-writing the function. That means you do have to make sure pytest imports it by installing it/specifying it in pytest_plugins/etc as well as importing it for reference. It also means this technically works with fake/dummy functions with the same name (in case you can't easily import some fixtures) example: from pytest_fixture_ref import using_fixtures_from_defaults, using_fixtures_from_kwargs @using_fixtures_from_defaults def test_bar1(_=fix_w_yield1, __=fix_w_yield2, tmp=tmp_path): assert tmp.exists() @using_fixtures_from_kwargs(_=fix_w_yield1, __=fix_w_yield2, tmp=tmp_path) def test_bar2(_, __, tmp): assert tmp.exists() You can also use it to reference fixtures from other fixtures @pytest.fixture def first_entry(): return \"a\" @pytest.fixture @using_fixtures_from_defaults def order(fe=first_entry): return [fe]","title":"Let developers reference pytest fixtures without name matching magic."},{"location":"#installation","text":"pip install pytest-fixture-ref","title":"Installation"},{"location":"#development","text":"Clone this repository Requirements: Poetry Python 3.7+ Create a virtual environment and install the dependencies poetry install Activate the virtual environment poetry shell","title":"Development"},{"location":"#testing","text":"pytest","title":"Testing"},{"location":"#documentation","text":"The documentation is automatically generated from the content of the docs directory and from the docstrings of the public signatures of the source code. The documentation is updated and published as a Github project page automatically as part each release.","title":"Documentation"},{"location":"#releasing","text":"Trigger the Draft release workflow (press Run workflow ). This will update the changelog & version and create a GitHub release which is in Draft state. Find the draft release from the GitHub releases and publish it. When a release is published, it'll trigger release workflow which creates PyPI release and deploys updated documentation.","title":"Releasing"},{"location":"#pre-commit","text":"Pre-commit hooks run all the auto-formatters (e.g. black , isort ), linters (e.g. mypy , flake8 ), and other quality checks to make sure the changeset is in good shape before a commit/push happens. You can install the hooks with (runs for each commit): pre-commit install Or if you want them to run only for each push: pre-commit install -t pre-push Or if you want e.g. want to run all checks manually for all files: pre-commit run --all-files This project was generated using the wolt-python-package-cookiecutter template.","title":"Pre-commit"},{"location":"api_docs/","text":"API documentation using_fixtures_from_defaults ( fn ) Pass fixtures to test/fixture via default value Examples: @using_fixtures_from_defaults def test_bar1(_=fix_w_yield1, __=fix_w_yield2, tmp=tmp_path): assert tmp.exists() Source code in pytest_fixture_ref/__init__.py def using_fixtures_from_defaults ( fn ): \"\"\" Pass fixtures to test/fixture via default value example: @using_fixtures_from_defaults def test_bar1(_=fix_w_yield1, __=fix_w_yield2, tmp=tmp_path): assert tmp.exists() \"\"\" signature = inspect . signature ( fn ) keyword_names_to_fixtures = { k : v . default for k , v in signature . parameters . items ()} assert all ( v is not inspect . Parameter . empty for v in keyword_names_to_fixtures . values () ), \"every parameter should have a matching fixture function provided as the default value\" keyword_names_to_fixture_names = { k : f . __name__ for ( k , f ) in keyword_names_to_fixtures . items () } fixture_names = keyword_names_to_fixture_names . values () z = textwrap . dedent ( f \"\"\" \\ def test_func( { ', ' . join ( fixture_names ) } ): return fn( { ', ' . join ( kname + '=' + fname for ( kname , fname ) in keyword_names_to_fixture_names . items ()) } ) \"\"\" ) scope = dict ( fn = fn ) exec ( z , scope ) test_func = scope [ \"test_func\" ] test_func . __name__ = fn . __name__ return test_func using_fixtures_from_kwargs ( ** fixture_kwargs ) Pass fixtures to test/fixture via decorator kwargs Examples: @using_fixtures_from_kwargs( =fix_w_yield1, __=fix_w_yield2, tmp=tmp_path) def test_bar2( , __, tmp): assert tmp.exists() Source code in pytest_fixture_ref/__init__.py def using_fixtures_from_kwargs ( ** fixture_kwargs ): \"\"\" Pass fixtures to test/fixture via decorator kwargs example: @using_fixtures_from_kwargs(_=fix_w_yield1, __=fix_w_yield2, tmp=tmp_path) def test_bar2(_, __, tmp): assert tmp.exists() \"\"\" def inner ( fn ): signature = inspect . signature ( fn ) keyword_names_to_fixtures = { k : fixture_kwargs . get ( k , None ) for k , v in signature . parameters . items () } assert set ( signature . parameters . keys ()) . issubset ( set ( fixture_kwargs . keys ())), ( \"every parameter should have a matching keyword argument in the decorator function\" ) keyword_names_to_fixture_names = { k : f . __name__ for ( k , f ) in keyword_names_to_fixtures . items () } fixture_names = keyword_names_to_fixture_names . values () z = textwrap . dedent ( f \"\"\" \\ def test_func( { ', ' . join ( fixture_names ) } ): return fn( { ', ' . join ( kname + '=' + fname for ( kname , fname ) in keyword_names_to_fixture_names . items ()) } ) \"\"\" ) scope = dict ( fn = fn ) exec ( z , scope ) test_func = scope [ \"test_func\" ] test_func . __name__ = fn . __name__ return test_func return inner","title":"API documentation"},{"location":"api_docs/#api-documentation","text":"","title":"API documentation"},{"location":"api_docs/#pytest_fixture_ref.using_fixtures_from_defaults","text":"Pass fixtures to test/fixture via default value Examples: @using_fixtures_from_defaults def test_bar1(_=fix_w_yield1, __=fix_w_yield2, tmp=tmp_path): assert tmp.exists() Source code in pytest_fixture_ref/__init__.py def using_fixtures_from_defaults ( fn ): \"\"\" Pass fixtures to test/fixture via default value example: @using_fixtures_from_defaults def test_bar1(_=fix_w_yield1, __=fix_w_yield2, tmp=tmp_path): assert tmp.exists() \"\"\" signature = inspect . signature ( fn ) keyword_names_to_fixtures = { k : v . default for k , v in signature . parameters . items ()} assert all ( v is not inspect . Parameter . empty for v in keyword_names_to_fixtures . values () ), \"every parameter should have a matching fixture function provided as the default value\" keyword_names_to_fixture_names = { k : f . __name__ for ( k , f ) in keyword_names_to_fixtures . items () } fixture_names = keyword_names_to_fixture_names . values () z = textwrap . dedent ( f \"\"\" \\ def test_func( { ', ' . join ( fixture_names ) } ): return fn( { ', ' . join ( kname + '=' + fname for ( kname , fname ) in keyword_names_to_fixture_names . items ()) } ) \"\"\" ) scope = dict ( fn = fn ) exec ( z , scope ) test_func = scope [ \"test_func\" ] test_func . __name__ = fn . __name__ return test_func","title":"using_fixtures_from_defaults()"},{"location":"api_docs/#pytest_fixture_ref.using_fixtures_from_kwargs","text":"Pass fixtures to test/fixture via decorator kwargs Examples: @using_fixtures_from_kwargs( =fix_w_yield1, __=fix_w_yield2, tmp=tmp_path) def test_bar2( , __, tmp): assert tmp.exists() Source code in pytest_fixture_ref/__init__.py def using_fixtures_from_kwargs ( ** fixture_kwargs ): \"\"\" Pass fixtures to test/fixture via decorator kwargs example: @using_fixtures_from_kwargs(_=fix_w_yield1, __=fix_w_yield2, tmp=tmp_path) def test_bar2(_, __, tmp): assert tmp.exists() \"\"\" def inner ( fn ): signature = inspect . signature ( fn ) keyword_names_to_fixtures = { k : fixture_kwargs . get ( k , None ) for k , v in signature . parameters . items () } assert set ( signature . parameters . keys ()) . issubset ( set ( fixture_kwargs . keys ())), ( \"every parameter should have a matching keyword argument in the decorator function\" ) keyword_names_to_fixture_names = { k : f . __name__ for ( k , f ) in keyword_names_to_fixtures . items () } fixture_names = keyword_names_to_fixture_names . values () z = textwrap . dedent ( f \"\"\" \\ def test_func( { ', ' . join ( fixture_names ) } ): return fn( { ', ' . join ( kname + '=' + fname for ( kname , fname ) in keyword_names_to_fixture_names . items ()) } ) \"\"\" ) scope = dict ( fn = fn ) exec ( z , scope ) test_func = scope [ \"test_func\" ] test_func . __name__ = fn . __name__ return test_func return inner","title":"using_fixtures_from_kwargs()"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased 0.0.4 - 2022-11-17 Fixed try to fix dev dependency 0.0.3 - 2022-11-17 Fixed update using_fixtures_from_kwargs to not accept defaults like the pre-split function did 0.0.2 - 2022-11-17 Changed split and rename into using_fixtures_from_defaults and using_fixtures_from_kwargs 0.0.1 - 2022-11-09 Added Add basic working functionality to avoid magic string references","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#004-2022-11-17","text":"","title":"0.0.4 - 2022-11-17"},{"location":"changelog/#fixed","text":"try to fix dev dependency","title":"Fixed"},{"location":"changelog/#003-2022-11-17","text":"","title":"0.0.3 - 2022-11-17"},{"location":"changelog/#fixed_1","text":"update using_fixtures_from_kwargs to not accept defaults like the pre-split function did","title":"Fixed"},{"location":"changelog/#002-2022-11-17","text":"","title":"0.0.2 - 2022-11-17"},{"location":"changelog/#changed","text":"split and rename into using_fixtures_from_defaults and using_fixtures_from_kwargs","title":"Changed"},{"location":"changelog/#001-2022-11-09","text":"","title":"0.0.1 - 2022-11-09"},{"location":"changelog/#added","text":"Add basic working functionality to avoid magic string references","title":"Added"}]}